export const getAssociativeLineTargetIndex=(t,e)=>t.nodeData.data.associativeLineTargets.findIndex((t=>t===e.nodeData.data.id));export const computeCubicBezierPathPoints=(t,e,o,i)=>{let r=t+(o-t)/2,n=e,a=r,x=i;return Math.abs(t-o)<=5&&(r=t+(i-e)/2,a=r),[{x:r,y:n},{x:a,y:x}]};export const joinCubicBezierPath=(t,e,o,i)=>`M ${t.x},${t.y} C ${o.x},${o.y} ${i.x},${i.y} ${e.x},${e.y}`;const getNodeRect=t=>{let{left:e,top:o,width:i,height:r}=t;return{right:e+i,bottom:o+r,left:e,top:o}};export const cubicBezierPath=(t,e,o,i)=>{let r=computeCubicBezierPathPoints(t,e,o,i);return joinCubicBezierPath({x:t,y:e},{x:o,y:i},r[0],r[1])};export const getNodePoint=(t,e="right")=>{let{left:o,top:i,width:r,height:n}=t;switch(e){case"left":return{x:o,y:i+n/2};case"right":return{x:o+r,y:i+n/2};case"top":return{x:o+r/2,y:i};case"bottom":return{x:o+r/2,y:i+n}}};export const computeNodePoints=(t,e)=>{let o=getNodeRect(t),i=(o.right+o.left)/2,r=(o.bottom+o.top)/2,n=getNodeRect(e),a=(n.right+n.left)/2-i,x=(n.bottom+n.top)/2-r;if(0===a&&0===x)return;let c="",s="";return a<=0&&a<=x&&a<=-x?(c="left",s="right"):a>0&&a>=-x&&a>=x?(c="right",s="left"):x<=0&&x<a&&x<-a?(c="top",s="bottom"):x>0&&-x<a&&x>a&&(c="bottom",s="top"),[getNodePoint(t,c),getNodePoint(e,s)]};export const getNodeLinePath=(t,e,o,i)=>{let r=getAssociativeLineTargetIndex(o,i),n=[],a=o.nodeData.data.associativeLineTargetControlOffsets;if(a&&a[r]){let o=a[r];n=[{x:t.x+o[0].x,y:t.y+o[0].y},{x:e.x+o[1].x,y:e.y+o[1].y}]}else n=computeCubicBezierPathPoints(t.x,t.y,e.x,e.y);return{path:joinCubicBezierPath(t,e,n[0],n[1]),controlPoints:n}};export const getDefaultControlPointOffsets=(t,e)=>{let o=computeCubicBezierPathPoints(t.x,t.y,e.x,e.y);return[{x:o[0].x-t.x,y:o[0].y-t.y},{x:o[1].x-e.x,y:o[1].y-e.y}]};
