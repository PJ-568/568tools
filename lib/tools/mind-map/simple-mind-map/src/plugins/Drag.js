import{bfsWalk,throttle}from"../utils";import Base from"../layouts/Base";class Drag extends Base{constructor({mindMap:e}){super(e.renderer),this.mindMap=e,this.reset(),this.bindEvent()}reset(){this.node=null,this.overlapNode=null,this.prevNode=null,this.nextNode=null,this.drawTransform=null,this.clone=null,this.line=null,this.placeholder=null,this.offsetX=0,this.offsetY=0,this.cloneNodeLeft=0,this.cloneNodeTop=0,this.isMousedown=!1,this.mouseDownX=0,this.mouseDownY=0,this.mouseMoveX=0,this.mouseMoveY=0,this.checkDragOffset=10}bindEvent(){this.checkOverlapNode=throttle(this.checkOverlapNode,300,this),this.mindMap.on("node_mousedown",((e,t)=>{if(this.mindMap.opt.readonly||e.isGeneralization)return;if(1!==t.which||e.isRoot)return;t.preventDefault(),this.drawTransform=this.mindMap.draw.transform();let{scaleX:i,scaleY:o,translateX:s,translateY:n}=this.drawTransform,{x:h,y:r}=this.mindMap.toPos(t.clientX,t.clientY);this.offsetX=h-(e.left*i+s),this.offsetY=r-(e.top*o+n),this.node=e,this.isMousedown=!0,this.mouseDownX=h,this.mouseDownY=r})),this.mindMap.on("mousemove",(e=>{if(this.mindMap.opt.readonly)return;if(!this.isMousedown)return;this.mindMap.emit("node_dragging",this.node),e.preventDefault();let{x:t,y:i}=this.mindMap.toPos(e.clientX,e.clientY);this.mouseMoveX=t,this.mouseMoveY=i,Math.abs(t-this.mouseDownX)<=this.checkDragOffset&&Math.abs(i-this.mouseDownY)<=this.checkDragOffset&&!this.node.isDrag||(this.mindMap.renderer.clearAllActive(),this.onMove(t,i))})),this.onMouseup=this.onMouseup.bind(this),this.mindMap.on("node_mouseup",this.onMouseup),this.mindMap.on("mouseup",this.onMouseup)}onMouseup(e){if(!this.isMousedown)return;this.isMousedown=!1;let t=this.node.isDrag;if(this.node.isDrag=!1,this.node.show(),this.removeCloneNode(),this.overlapNode)this.mindMap.renderer.setNodeActive(this.overlapNode,!1),this.mindMap.execCommand("MOVE_NODE_TO",this.node,this.overlapNode);else if(this.prevNode)this.mindMap.renderer.setNodeActive(this.prevNode,!1),this.mindMap.execCommand("INSERT_AFTER",this.node,this.prevNode);else if(this.nextNode)this.mindMap.renderer.setNodeActive(this.nextNode,!1),this.mindMap.execCommand("INSERT_BEFORE",this.node,this.nextNode);else if(t&&this.mindMap.opt.enableFreeDrag){let{x:t,y:i}=this.mindMap.toPos(e.clientX-this.offsetX,e.clientY-this.offsetY),{scaleX:o,scaleY:s,translateX:n,translateY:h}=this.drawTransform;t=(t-n)/o,i=(i-h)/s,this.node.left=t,this.node.top=i,this.node.customLeft=t,this.node.customTop=i,this.mindMap.execCommand("SET_NODE_CUSTOM_POSITION",this.node,t,i),this.mindMap.render()}this.reset(),this.mindMap.emit("node_dragend")}createCloneNode(){this.clone||(this.clone=this.node.group.clone(),this.clone.opacity(.5),this.clone.css("z-index",99999),this.node.isDrag=!0,this.node.hide(),this.line=this.draw.path(),this.line.opacity(.5),this.node.styleLine(this.line,this.node),this.placeholder=this.draw.rect().fill({color:this.node.style.merge("lineColor",!0)}),this.mindMap.draw.add(this.clone))}removeCloneNode(){this.clone&&(this.clone.remove(),this.line.remove(),this.placeholder.remove())}onMove(e,t){if(!this.isMousedown)return;this.createCloneNode();let{scaleX:i,scaleY:o,translateX:s,translateY:n}=this.drawTransform;this.cloneNodeLeft=e-this.offsetX,this.cloneNodeTop=t-this.offsetY,e=(this.cloneNodeLeft-s)/i,t=(this.cloneNodeTop-n)/o;let h=this.clone.transform();this.clone.translate(e-h.translateX,t-h.translateY);let r=this.node.parent;this.line.plot(this.quadraticCurvePath(r.left+r.width/2,r.top+r.height/2,e+this.node.width/2,t+this.node.height/2)),this.checkOverlapNode()}checkOverlapNode(){if(!this.drawTransform)return;let e=this.mouseMoveX,t=this.mouseMoveY;this.overlapNode=null,this.prevNode=null,this.nextNode=null,this.placeholder.size(0,0),bfsWalk(this.mindMap.renderer.root,(i=>{if(i.nodeData.data.isActive&&this.mindMap.renderer.setNodeActive(i,!1),i===this.node||this.node.isParent(i))return;if(this.overlapNode||this.prevNode&&this.nextNode)return;let o=this.getNodeRect(i),s=o.height/4,n=i.parent?i.parent.children.filter((e=>e!==this.node)):[],h=n.findIndex((e=>e===i)),r=null,d=null;-1!==h&&(h-1>=0&&(r=n[h-1]),h+1<=n.length-1&&(d=n[h+1]));let l=0;if(r){let e=this.getNodeRect(r);l=o.top-e.bottom,l=l>=10?l/2:0}else l=10;let a=0;if(d){a=this.getNodeRect(d).top-o.bottom,a=a>=10?a/2:0}else a=10;if(o.left<=e&&o.right>=e){if(!(this.overlapNode||this.prevNode||this.nextNode||i.isRoot)){let e=a>0?t>o.bottom&&t<=o.bottom+a:t>=o.bottom-s&&t<=o.bottom,n=l>0?t<o.top&&t>=o.top-l:t>=o.top&&t<=o.top+s;if(e){this.prevNode=i;let e=a>0?a:5;this.placeholder.size(i.width,e).move(o.originLeft,o.originBottom)}else if(n){this.nextNode=i;let e=l>0?l:5;this.placeholder.size(i.width,e).move(o.originLeft,o.originTop-e)}}this.overlapNode||this.prevNode||this.nextNode||o.top+(l>0?0:s)<=t&&o.bottom-(a>0?0:s)>=t&&(this.overlapNode=i)}})),this.overlapNode&&this.mindMap.renderer.setNodeActive(this.overlapNode,!0)}getNodeRect(e){let{scaleX:t,scaleY:i,translateX:o,translateY:s}=this.drawTransform,{left:n,top:h,width:r,height:d}=e,l=n,a=h,p=h+d,m=(n+r)*t+o,c=(h+d)*i+s;return n=n*t+o,h=h*i+s,{width:r,height:d,left:n,top:h,right:m,bottom:c,originLeft:l,originTop:a,originBottom:p}}}Drag.instanceName="drag";export default Drag;
